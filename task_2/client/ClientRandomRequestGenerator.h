#ifndef CLIENTRANDOMREQUESTGENERATOR_H
#define CLIENTRANDOMREQUESTGENERATOR_H

#include <QVariantMap>

/*!
 * \brief The ClientRandomRequestGenerator class
 * это наколеночный класс, который определяет логику работы клиента, какие
 * запросы он шлёт.
 *
 * Вообще, планировалось продемонстрировать работу со словарём на сервере, потому что
 * кроме этого в голову пришло только взять где-то реализацию lock-free очереди и добавлять в
 * неё данные. И удалять, да. Но выглядит в коде не так эпично. А конкретики не было.
 *
 * Здесь используются небольшие костыли, исключительно в демонстрационных целях -- хотелось именно
 * через клиенты наагенерировать данные для удобства, потому есть запрос о списке ключей, потому же и нет
 * удаления -- это переусложнило бы демонстрацию, заставив писать много ненужной  логики. Потому добавление и
 * обновление выбираются независимо, хоть это и один вид запроса получился.
 *
 * В общем, на основе рандома этот класс умеет готовить запрос к серверу. Чтения должно стать больше, согласно заданию,
 * именно когда наберётся адекватное количество ключей.
 *
 */
class ClientRandomRequestGenerator
{
public:
    /*!
     * \brief createRandomRequest -- генерирует данные случайного запроса
     * \return                    -- несмотря на QVariant, там строки
     */
    QVariantMap createRandomRequest();

    /*!
     * \brief setKnownKeys -- позволяет установить список доступных ключей словаря, для этого
     * специально сделан единственный запрос, который используется. Вообще это не очень всё корректно, но
     * не хотелось хардкодить чтение/запись
     * \param keys         -- список ключей
     */
    void setKnownKeys(const QStringList& keys);

    /*!
     * \brief keyListIsEmpty -- можно узнать, получены ли ключи словаря
     * \return  -- есть/нет доступные ключи
     */
    bool keyListIsEmpty() const;

    /*!
     * \brief createKeyListRequest -- тот самый запрос на получение списка ключей, считается чтением,
     * повторяется изредка, таким образом контейнер накапливает ключи по нарастающей, не сразу.
     * \return -- данные запроса
     */
    static QVariantMap createKeyListRequest();

private:
    QStringList m_knownKeys;
};


#endif // CLIENTRANDOMREQUESTGENERATOR_H
